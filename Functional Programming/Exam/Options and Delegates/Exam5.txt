 Question 1 on options:
----------------------

=>Reasoning: 

Usualy cyclone warnings are sent based on the wind speed, weather and some other criterias. So we may get valid data or not from the
input. So we will use options to validate whether to send cyclone warning or not.
Requirements to consider for cyclone warning:
wind speed should be atleast 35 knots and weather is maximum of 15 degrees
we will store the scenarios in list and find what among them are valid scenarios for cyclone warnings 

=>Program:

using LaYumba.Functional;
using System;
using System.Collections.Generic;
using System.Linq;
using static LaYumba.Functional.F;

namespace FinalExamination
{
    class CycloneWarnings
    {
        public static void Main(string[] args)
        {
            List<Tuple<string, double, double>> cycloneScenarios = new()
            {
                Tuple.Create("Scenario 1", 95.0, 12.0),
                Tuple.Create("Scenario 2", 75.0, 22.0),
                Tuple.Create("Scenario 3", -105.0, 11.0),
                Tuple.Create("Scenario 4", 105.0, 12.0)
            };

            foreach (var cycl in cycloneScenarios)
            {
                Option<Cyclone> cyclone = Cyclone.cycloneWarningCheck(cycl);
                if (cyclone.ToString().ToLower().Equals("none"))
                    Console.WriteLine(cycl.Item1 + " with speed " + cycl.Item2 + " and weather " + cycl.Item3 + " is not valid for cyclone warning");
                else
                    Console.WriteLine(cycl.Item1 + " with speed " + cycl.Item2 + " and weather " + cycl.Item3 + " is valid for cyclone warning");
            }
        }
        public class Cyclone
        {
            public bool toBeWarned { get; }
            public Cyclone(bool warn) => this.toBeWarned = warn;

            public static implicit operator bool(Cyclone ep) => ep.toBeWarned;

            public static Func<Tuple<string, double, double>, Option<Cyclone>> cycloneWarningCheck = cyclone => 
                    validWindSpeed(cyclone.Item2) && isEligible(cyclone) ? Some(new Cyclone(true)) : None;

            static Func<double, bool> validWindSpeed = (speed) => speed >= 0;

            static Func<Tuple<string, double, double>, bool> isEligible = cyclone => cyclone.Item3 <= 15 && 
                                cyclone.Item2 >= 35;
        }
    }
}

Question 2 on options:
----------------------

=>Reasoning:

In schools or colleges students will get scholarship based on income or grades. When we get the application forms we may get valid or
invalid data. So we use the concept of options to validate whether the student is eligible for scholarship or not.
Eligibility for scholarship : income should not be more than $50000 per year and grade should be A or A+

=>Program:

using LaYumba.Functional;
using System;
using System.Collections.Generic;
using System.Linq;
using static LaYumba.Functional.F;

namespace FinalExamination
{
    class StudentScholarship
    {
        public static void Main(string[] args)
        {
            List<Tuple<string, int, string>> students = new()
            {
                Tuple.Create("Cristiano", 40000, "A"),
                Tuple.Create("Messi", 56000, "A+"),
                Tuple.Create("David", -20000, "A+"),
                Tuple.Create("Robert", 48000,"A+")
            };

            foreach (var stud in students)
            {
                Option<Student> isEmergingPlayer = Student.functionScholarshipEligible(stud);
                if (isEmergingPlayer.ToString().ToLower().Equals("none"))
                    Console.WriteLine(stud.Item1 + " is not eligible for scholarship");
                else
                    Console.WriteLine(stud.Item1 + " is eligible for scholarship");
            }
        }
        public class Student
        {
            public bool isElgibleForScholarship { get; }
            public Student(bool isEligible) => this.isElgibleForScholarship = isEligible;

            public static implicit operator bool(Student ep) => ep.isElgibleForScholarship;

            public static Func<Tuple<string, int, string>, Option<Student>> functionScholarshipEligible = student => 
                    isValidIncome(student.Item2) && isEligible(student) ? Some(new Student(true)) : None;

            static Func<int, bool> isValidIncome = (income) => income >= 0;

            static Func<Tuple<string, int, string>, bool> isEligible = student => student.Item2 <= 50000 && 
                                (student.Item3.ToLower().Equals("a") || student.Item3.ToLower().Equals("a+"));
        }
    }
}


Question 3 on multicast delegates:
----------------------------------

=>Reasoning: 

Generally people will go to trips and at the end of the day they want to know the mileage and average speed based on the total distance
travelled and time taken and fuel consumed.
For the following program we will calculate mileage and average speed in one invoke call by taking the inputs from user

=>Program:

using System;

namespace FinalExamination
{
    public delegate void CalculateMileageAndAverageSpeed(double distance, double time, double fuel);
    class MileageAndAverageSpeed
    {
        public static Func<double, double, double, double> funcMileage = (distance, time, fuel) 
            => distance / fuel;
        public static Func<double, double, double, double> funcAvgSpeed = (distance, time, fuel) 
            => distance / time;
        public static void calculateMileage(double distance, double time, double fuel) 
        {
            Console.WriteLine("Mileage: " + Math.Round(funcMileage(distance, time, fuel),3) + " miles/litre");
        }
        public static void calculateAverageSpeed(double distance, double time, double fuel)
        {
            Console.WriteLine("Average speed: " + Math.Round(funcAvgSpeed(distance, time, fuel), 3) + " miles/hour");
        }
        public static void Main(string[] args)
        {
            Console.Write("Enter total distance travelled in miles: ");
            double distance = double.Parse(Console.ReadLine());
            Console.Write("Enter total time travelled in hours: ");
            double hours = double.Parse(Console.ReadLine());
            Console.Write("Enter total fuel consumed in litres: ");
            double fuel = double.Parse(Console.ReadLine());
            CalculateMileageAndAverageSpeed mileageAndAvgSpeed = calculateMileage;
            mileageAndAvgSpeed += calculateAverageSpeed;
            mileageAndAvgSpeed.Invoke(distance, hours, fuel);
        }
    }
}

Question 4 on multicast delegates:
----------------------------------

=>Reasoning: 

Generally we have 2 types of interest calculations simple interest and compound interest and we want to know the values of these 2 types for a given
principal, rate of interest and time. 
For the following program we will calculate simple interest and compound interest in one invoke call by taking the inputs from user

=>Program:

using System;

namespace FinalExamination
{
    public delegate void CalculateInterest(double principalAmount, double rateOfInterest, int time);
    class SimpleInterestAndCompoundInterest
    {
        public static Func<double, double, int, double> funcSI = (principalAmount, rateOfInterest, time) => (principalAmount * (time/12) * rateOfInterest)/100;
        public static Func<double, double, int, double> funcCI = (principalAmount, rateOfInterest, time) => principalAmount * Math.Pow(1 + rateOfInterest/100, (time / 12)) - principalAmount;
        public static void calculateSimpleInterest(double principalAmount, double rateOfInterest, int time) 
        {
            Console.WriteLine("Simple Interest: " + Math.Round(funcSI(principalAmount, rateOfInterest, time),3));
        }
        public static void calculateCompoundInterest(double principalAmount, double rateOfInterest, int time)
        {
            Console.WriteLine("Compound Interest: " + Math.Round(funcCI(principalAmount, rateOfInterest, time), 3));
        }
        public static void Main(string[] args)
        {
            Console.Write("Enter principal amount: ");
            double principalAmount = double.Parse(Console.ReadLine());
            Console.Write("Enter rate of interest per year: ");
            double rateOfInterest = double.Parse(Console.ReadLine());
            Console.Write("Enter duration in months: ");
            int months = Convert.ToInt32(Console.ReadLine());
            CalculateInterest calDiffInterest = calculateSimpleInterest;
            calDiffInterest += calculateCompoundInterest;
            calDiffInterest.Invoke(principalAmount, rateOfInterest, months);
        }
    }
}