 Question 1 on options:
----------------------

=>Reasoning: 
 
Based on the BMI of the person we can check whether he/she falls in obesity range. If the BMI is 30.0 or higher, then it falls under the obesity range.
We use the options concept to return something when the person falls under obesity range based on the given weight and height.
For the program we are taking a list of person objects with height and weight and we will return the people who fall under obesity range.  

=>Program:

using LaYumba.Functional;
using System;
using System.Collections.Generic;
using System.Linq;
using static LaYumba.Functional.F;

namespace OptionsAndDelegates
{
    class Opt1
    {
        static void Main(string[] args)
        {
            string peopleFallingUnderObesityCategory(Option<List<Person>> person)
                => person.Match<string>(
                    () => "Provide valid input",
                    (pers) => string.Join(",", 
                                pers.FindAll(per => (per.weight / ((per.height/100) * (per.height / 100)) >= 30))
                                .Select(x => x.name).ToArray()) + " people fall under obesity category"
                );
            List<Person> mobileList = new()
            {
                new Person("\"Alex\"", 160, 80),
                new Person("\"Robert\"", 172, 68),
                new Person("\"Kara\"", 145, 79),
                new Person("\"Sierra\"", 153, 52),
                new Person("\"Julie\"", 158, 58)
            };
            Console.WriteLine("Obesity is measured based on BMI using options:");
            Option<List<Person>> mob = Some(mobileList);
            Console.WriteLine(peopleFallingUnderObesityCategory(mob));
        }
    }
    class Person
    {
        public string name { get; set; }
        public double height { get; set; }
        public double weight { get; set; }
        public Person(string name, double height, double weight)
        {
            this.name = name;
            this.height = height;
            this.weight = weight;
        }
    }
}

Question 2 on options:
----------------------

=>Reasoning:

A number is called prime when the number is divided and itself. So we will find if the number is prime based on the integer provided. User may 
enter both valid and invalid integer values. Options can be used to send some value (if it is a prime) or none (if the integer is invalid or not
prime).

=>Program:

using LaYumba.Functional;
using System;
using System.Collections.Generic;
using static LaYumba.Functional.F;

namespace OptionsAndDelegates
{
    class Opt2
    {
        static void Main(string[] args)
        {
            List<int> numbersList = new() { 20, 21, 25, 40, 41, 42, 60, 67, 69, 80 };
            foreach(int number in numbersList)
            {
                Option<IsPrimeNumber> firstNumber = IsPrimeNumber.Number(number);
                if (!firstNumber.ToString().ToLower().Equals("none"))
                    Console.WriteLine(number + " is prime number");
            }
        }
    }
    public class IsPrimeNumber
    {
        public bool IsPrime { get; }
        public IsPrimeNumber(bool prime) => IsPrime = prime;

        public static implicit operator bool(IsPrimeNumber pr) => pr.IsPrime;
        public static Option<IsPrimeNumber> Number(int number) => checkIsPrimeNumber(number) ? Some(new IsPrimeNumber(true)) : None;
        private static bool checkIsPrimeNumber(int number) {
            if (number == 0 || number == 1)
                return false;
            else
            for (int a = 2; a <= number / 2; a++)
                    if (number % a == 0)
                        return false;
            return true;
        }
    }
}


Question 3 on multicast delegates:
----------------------------------

=>Reasoning: 

When we travel we usually search for different modes of transport from source to destination. We will use multicast delegates for this scenario where
we call different methods with source and destination to get different type of transport available. 
In the following program we will consider 3 modes of transport. Road, train and air. We will available vehicles for each mode in each individual list
and when we search available transport from source to destination we will have different calls to individual methods to get the corresponding transport
mode options with one invoke method using the multicast delegates

=>Program:

using LaYumba.Functional;
using System;
using System.Collections.Generic;
using System.Linq;

namespace OptionsAndDelegates
{
    public delegate void ModesOfTransport(string source, string destination);
    class Del1
    {
        static List<TransportVehicle> air;
        static List<TransportVehicle> train;
        static List<TransportVehicle> road;
        static void getAirModeTimings(string source, string destination)
        {
            Console.WriteLine();
            if (air.FindAll(a => a.source.Equals(source) && a.destination.Equals(destination)).Count > 0)
            {
                Console.WriteLine("Air mode transport available from " + source + " to " + destination + " at following times");
                Console.WriteLine(string.Join("\n", air.FindAll(a => a.source.Equals(source) && a.destination.Equals(destination)).Select(x=> x.time).ToArray()));
            }
            else 
                Console.WriteLine("No vehicles found via air");
        }
        static void getTrainModeTimings(string source, string destination)
        {
            Console.WriteLine();
            if (train.FindAll(a => a.source.Equals(source) && a.destination.Equals(destination)).Count > 0)
            {
                Console.WriteLine("Train mode transport available from " + source + " to " + destination + " at following times");
                Console.WriteLine(string.Join("\n", train.FindAll(a => a.source.Equals(source) && a.destination.Equals(destination)).Select(x => x.time).ToArray()));
            }
            else
                Console.WriteLine("No vehicles found via train");
        }
        static void getRoadModeTimings(string source, string destination)
        {
            Console.WriteLine();
            if (road.FindAll(a => a.source.Equals(source) && a.destination.Equals(destination)).Count > 0)
            {
                Console.WriteLine("Road mode transport available from " + source + " to " + destination + " at following times");
                Console.WriteLine(string.Join("\n", road.FindAll(a => a.source.Equals(source) && a.destination.Equals(destination)).Select(x => x.time).ToArray()));
            }
            else
                Console.WriteLine("No vehicles found via road");
        }
        static void Main(string[] args)
        {
            generateStaticAirData();
            generateStaticTrainData();
            generateStaticRoadData();
            Console.WriteLine("Please enter source and destination from places chicago, new york and washington");
            Console.Write("Please enter source: ");
            string source = Console.ReadLine();
            Console.Write("Please enter destination: ");
            string destination = Console.ReadLine();
            Console.WriteLine("\n Using multiCast delegates all the available vehicles via air, train or road are checked with a single invoke call\n");
            ModesOfTransport modesOfTrasnportDelegate = getAirModeTimings;
            modesOfTrasnportDelegate += getTrainModeTimings;
            modesOfTrasnportDelegate += getRoadModeTimings;
            modesOfTrasnportDelegate.Invoke(source, destination);
        }

        private static void generateStaticRoadData()
        {
            road = new List<TransportVehicle>
            {
                new TransportVehicle("chicago", "washington", new DateTime(2021, 10, 11, 21, 10, 0), 76),
                new TransportVehicle("chicago", "washington", new DateTime(2021, 10, 11, 6, 30, 0), 55),
                new TransportVehicle("new york", "chicago", new DateTime(2021, 10, 11, 23, 0, 0), 86),
                new TransportVehicle("washington", "chicago", new DateTime(2021, 10, 11, 17, 50, 0), 67),
                new TransportVehicle("new york", "washington", new DateTime(2021, 10, 11, 6, 10, 0), 25),
                new TransportVehicle("washington", "new york", new DateTime(2021, 10, 11, 9, 50, 0), 24)
            };
        }

        private static void generateStaticTrainData()
        {
            train = new List<TransportVehicle>
            {
                new TransportVehicle("chicago", "new york", new DateTime(2021, 10, 11, 15, 10, 0), 56),
                new TransportVehicle("chicago", "new york", new DateTime(2021, 10, 11, 5, 0, 0), 45),
                new TransportVehicle("chicago", "washington", new DateTime(2021, 10, 11, 20, 30, 0), 52),
                new TransportVehicle("new york", "chicago", new DateTime(2021, 10, 11, 3, 0, 0), 54),
                new TransportVehicle("new york", "chicago", new DateTime(2021, 10, 11, 14, 30, 0), 46),
                new TransportVehicle("washington", "chicago", new DateTime(2021, 10, 11, 17, 50, 0), 39),
            };
        }

        private static void generateStaticAirData()
        {
            air = new List<TransportVehicle>
            {
                new TransportVehicle("chicago", "new york", new DateTime(2021, 10, 11, 5, 10, 0), 80),
                new TransportVehicle("chicago", "new york", new DateTime(2021, 10, 11, 15, 0, 0), 95),
                new TransportVehicle("chicago", "washington", new DateTime(2021, 10, 11, 10, 30, 0), 75),
                new TransportVehicle("new york", "chicago", new DateTime(2021, 10, 11, 13, 0, 0), 72),
                new TransportVehicle("new york", "chicago", new DateTime(2021, 10, 11, 4, 30, 0), 78),
                new TransportVehicle("washington", "chicago", new DateTime(2021, 10, 11, 7, 50, 0), 59),
                new TransportVehicle("new york", "washington", new DateTime(2021, 10, 11, 11, 10, 0), 35),
                new TransportVehicle("washington", "new york", new DateTime(2021, 10, 11, 18, 50, 0), 32)
            };
        }
    }
    public class TransportVehicle
    {
        public string source { get; set; }
        public string destination { get; set; }
        public DateTime time { get; set; }
        public double cost { get; set; }
        public TransportVehicle(string so, string dest, DateTime time, double cost)
        {
            this.source = so;
            this.destination = dest;
            this.time = time;
            this.cost = cost;
        }
    }
}

Question 4 on multicast delegates:
----------------------------------

=>Reasoning: 

When we buy any land we want to know the area of the land along with perimeter as well as the cost of the total area when the cost of each square feet
is given. We can use multiCast delegates to calculate all the different attributes with a single invoke using the inputs and display the values.
In the program we will calculate area, perimeter and total cost for a given user input of length and width

=>Program:

using System;

namespace OptionsAndDelegates
{
    public delegate void RealEstateAttributes(double length, double breadth);
    class Del2
    {
        static double priceForEachSquareFeet;
        static void calculateArea(double length, double width) => Console.WriteLine("Area of the land is: " + length * width + " square feet");
        static void calculatePerimeter(double length, double width) => Console.WriteLine("Area of the land is: " + 2*(length + width) + " feet");
        static void calculateCost(double length, double width) => Console.WriteLine("Total cost of the land is: $" + length * width * priceForEachSquareFeet);
        static void Main(string[] args)
        {
            Console.Write("Please enter length of the land in feet: ");
            double length = double.Parse(Console.ReadLine());
            Console.Write("Please enter width of the land in feet: ");
            double width = double.Parse(Console.ReadLine());
            Console.Write("Please enter price for each square feet: $");
            priceForEachSquareFeet = double.Parse(Console.ReadLine());
            Console.WriteLine("\n Using multiCast delegates we will calculate area, perimeter and cost in a single invoke call\n");
            RealEstateAttributes realEstateLand = calculateArea;
            realEstateLand += calculatePerimeter;
            realEstateLand += calculateCost;
            realEstateLand.Invoke(length, width);
        }
    }
}
