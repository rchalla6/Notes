 Question 1 on options:
----------------------

=>Reasoning: 
 
Based on the BMI of the person we can check whether he/she falls in obesity range. If the BMI is 30.0 or higher, then it falls under the obesity range.
We use the options concept to return something when the person falls under obesity range based on the given weight and height.
For the program we are taking a list of person objects with height and weight and we will return the people who fall under obesity range.  

=>Program:

using LaYumba.Functional;
using System;
using System.Collections.Generic;
using System.Linq;
using static LaYumba.Functional.F;

namespace OptionsAndDelegates
{
    class Opt1
    {
        static void Main(string[] args)
        {
            string peopleFallingUnderObesityCategory(Option<List<Person>> person)
                => person.Match<string>(
                    () => "Provide valid input",
                    (pers) => string.Join(",", 
                                pers.FindAll(per => (per.weight / ((per.height/100) * (per.height / 100)) >= 30))
                                .Select(x => x.name).ToArray()) + " people fall under obesity category"
                );
            List<Person> mobileList = new()
            {
                new Person("\"Alex\"", 160, 80),
                new Person("\"Robert\"", 172, 68),
                new Person("\"Kara\"", 145, 79),
                new Person("\"Sierra\"", 153, 52),
                new Person("\"Julie\"", 158, 58)
            };
            Console.WriteLine("Obesity is measured based on BMI using options:");
            Option<List<Person>> mob = Some(mobileList);
            Console.WriteLine(peopleFallingUnderObesityCategory(mob));
        }
    }
    class Person
    {
        public string name { get; set; }
        public double height { get; set; }
        public double weight { get; set; }
        public Person(string name, double height, double weight)
        {
            this.name = name;
            this.height = height;
            this.weight = weight;
        }
    }
}

Question 2 on options:
----------------------

=>Reasoning:

A number is called prime when the number is divided and itself. So we will find if the number is prime based on the integer provided. User may 
enter both valid and invalid integer values. Options can be used to send some value (if it is a prime) or none (if the integer is invalid or not
prime).

=>Program:

using LaYumba.Functional;
using System;
using System.Collections.Generic;
using static LaYumba.Functional.F;

namespace OptionsAndDelegates
{
    class Opt2
    {
        static void Main(string[] args)
        {
            List<int> numbersList = new() { 20, 21, 25, 40, 41, 42, 60, 67, 69, 80 };
            foreach(int number in numbersList)
            {
                Option<IsPrimeNumber> firstNumber = IsPrimeNumber.Number(number);
                if (!firstNumber.ToString().ToLower().Equals("none"))
                    Console.WriteLine(number + " is prime number");
            }
        }
    }
    public class IsPrimeNumber
    {
        public bool IsPrime { get; }
        public IsPrimeNumber(bool prime) => IsPrime = prime;

        public static implicit operator bool(IsPrimeNumber pr) => pr.IsPrime;
        public static Option<IsPrimeNumber> Number(int number) => checkIsPrimeNumber(number) ? Some(new IsPrimeNumber(true)) : None;
        private static bool checkIsPrimeNumber(int number) {
            if (number == 0 || number == 1)
                return false;
            else
            for (int a = 2; a <= number / 2; a++)
                    if (number % a == 0)
                        return false;
            return true;
        }
    }
}


Question 3 on multicast delegates:
----------------------------------

=>Reasoning: 

When we travel we usually search for different modes of transport from source to destination. We will use multicast delegates for this scenario where
we call different methods with source and destination to get different type of transport available. 
In the following program we will consider 3 modes of transport. Road, train and air. We will available vehicles for each mode in each individual list
and when we search available transport from source to destination we will have different calls to individual methods to get the corresponding transport
mode options with one invoke method using the multicast delegates

=>Program:



Question 4 on multicast delegates:
----------------------------------

=>Reasoning: 

When we take a home loan to buy a house we usually wants to know the interest amount we pay and the emi payment schedule. So for a given principal
interest rate and no of years we find the mortgage and the payment schedule using the multicast delegates
So for a given principal, interest and no of years using delegates we find
1. Mortgage
2. Payment schedule

=>Program:



