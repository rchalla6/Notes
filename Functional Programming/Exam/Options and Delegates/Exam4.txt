 Question 1 on options:
----------------------

=>Reasoning: 
 
While we withdraw money we need to have sufficient balance in account for that to be considered as eligible transaction. Customer can enter any value
while withdrawing the money. We need to check if that is a valid number as well as the balance is sufficient for the withdrawal transaction. We will 
use options concept to achieve this where we return some (when it is an eligible transaction) or none (if it is not eligible transaction) 

=>Program:

using LaYumba.Functional;
using static LaYumba.Functional.F;
using System;
using System.Collections.Generic;

namespace FinalExam
{
    class Progam1OnOptions
    {
        static void Main(string[] args)
        {
            List<Tuple<string, double>> bankCustomerDetails = new List<Tuple<string, double>>
            {
                Tuple.Create("1234",25000.0),
                Tuple.Create("2345",32000.0),
                Tuple.Create("3456",2211.0),
                Tuple.Create("4567",10000.0)
            };
            Console.WriteLine("Enter your bank account:");
            string bankAccount = Console.ReadLine();
            Console.WriteLine("Enter how much money you want to withdraw:");
            double withdrawAmount = double.Parse(Console.ReadLine());
            Option<IsEligibleTransaction> transaction = IsEligibleTransaction.transaction(bankAccount,withdrawAmount,bankCustomerDetails);
            if (transaction.ToString().ToLower().Equals("none"))
                Console.WriteLine("Not an eligible transaction");
            else
                Console.WriteLine("Eligible transaction");
            Console.WriteLine("Options result: " + transaction);
        }
    }
    public class IsEligibleTransaction
    {
        public bool isEligibleTrans { get; }
        public IsEligibleTransaction(bool isEligible) => isEligibleTrans = isEligible;
        public static implicit operator bool(IsEligibleTransaction elig) => elig.isEligibleTrans;
        public static Func<string,double, List<Tuple<string, double>>, Option<IsEligibleTransaction>> transaction = 
            (account, amount, bankAccounts) => isValidWithdrawalAmount(amount) && isValidAccount(account, bankAccounts) && isValidTransaction(account, amount, bankAccounts) ? Some(new IsEligibleTransaction(true)) : None;
        static Func<double, bool> isValidWithdrawalAmount = amount => amount > 0;
        static Func<string, List<Tuple<string, double>>, bool> isValidAccount = (account, accounts ) 
            => accounts.FindAll(acc => acc.Item1.Equals(account)).Count > 0;
        static Func<string, double, List<Tuple<string, double>>, bool> isValidTransaction = (account, amount, accounts)
            => accounts.FindAll(acc => acc.Item1.Equals(account) && acc.Item2 > amount).Count > 0;
    }
}

Question 2 on options:
----------------------

=>Reasoning:

Banks will approve loan based on the credit score. So for a given credit score we need to provide whether the customer is eligible for loan or not.
Users can provide any value for the credit score. We need to validate the credit score and provide the response.
For the following program we consider credit score to be atleast 670 for loan to be approved.

=>Program:

using LaYumba.Functional;
using static LaYumba.Functional.F;
using System;
using System.Collections.Generic;

namespace FinalExam
{
    class Progam2OnOptions
    {
        static void Main(string[] args)
        {
            List<int> creditScores = new() { 554,765,496,802,599,-800 };
            foreach(int creditScore in creditScores)
            {
                Option<LoanApproved> loan = LoanApproved.checkCreditScoreForLoanApproval(creditScore);
                if (loan.ToString().ToLower().Equals("none"))
                    Console.WriteLine("Credit Score " + creditScore + " is not eligible for loan dispersal");
                else
                    Console.WriteLine("Credit Score " + creditScore + " is eligible for loan dispersal");
            }
        }
    }
    public class LoanApproved
    {
        public bool IsLoanApproved { get; }
        public LoanApproved(bool isEligible) => IsLoanApproved = isEligible;

        public static implicit operator bool(LoanApproved loanApproved) => loanApproved.IsLoanApproved;

        public static Func<int, Option<LoanApproved>> checkCreditScoreForLoanApproval = (credScore) => isValidCredScore(credScore) && isCredScoreSufficient(credScore) ? Some(new LoanApproved(true)) : None;
        
        static readonly Func<int, bool> isValidCredScore = score => score > 0;
        
        static readonly Func<int, bool> isCredScoreSufficient = score => score >= 670;
    }
}

Question 3 on multicast delegates:
----------------------------------

=>Reasoning: 

When we prepare any dish we need a set of ingredients and based on the quantity of the preparation of dish the quantity of ingredients changes. 
For the following program we will take the preparation of chicken pickle dish and find the quantity of ingredients required for the quantity of
preparation of pickle given by user.
For 1 kg preparation of pickle we consider the following amount of quantity for each ingredient

2 table spoon turmeric powder
2 cups chilli powder
1/2kg mustard oil
3/4th cup salt
1cup lemon juice
100g ginger

=>Program:



Question 4 on multicast delegates:
----------------------------------

=>Reasoning: 

When we buy any land we want to know the area of the land along with perimeter as well as the cost of the total area when the cost of each square feet
is given. We can use multiCast delegates to calculate all the different attributes with a single invoke using the inputs and display the values.
In the program we will calculate area, perimeter and total cost for a given user input of length and width

=>Program:


